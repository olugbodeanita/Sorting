#include <iostream>
#include <string>

template<class T>
void swap(T& x, T& y){
  T temp = x;
  x = y;
  y = temp;
}

template<class T>
void quicksort(T data[], int n){
  //base case
  if (low >= high){
    return;
  }
  //find a pivot item, partition array according to what the pivot is
  int pivdex = partition(data, low, high);
   //call this sort method recursively on left array
  quicksort(data, low, pivdex - 1);
   //call this sort method recursively on right array
  quicksort(data, pivdex + 1, high);
}

template<class T>
void print(T data, int n){
  for(int i = 0; i < n; i++){
    std::cout << data[i] << std::endl;
  }
}

int main(){
  int data[] = {4, 2, 1, 5, 3};
  
  int n = sizeof(data)/sizeof(data[0]);
  
  bubbleSort(data, n);
  print(data, n);
}
/*
quicksort(array, low, high){
  //base case
  if low >= high ( return )
  //find a pivot item, partition array according to what the pivot is
  pivot = partition(array, low, high)
  //call this sort method recursively on left array
  quicksort(array, low, pivot - 1)
  //call this sort method recursively on right array
  quicksort(array, pivot, high)
  
  end
}

partition(array, low, high){
  //we could generate a random item for the pivot, but we're using a middle item instead
  pivotIndex = (low+high)/2
  //make the pivot be the last item in the array
  swap(pivotIndex, high)
  
  i = low
  //loop decides what are the items that will be on the left side of the pivot or the right side of the pivot
  for(low to high){
    if array[j] <= array[high]{
      swap(i, j)
      i++
    }
  }
  //i tracks threshold item -> separates items that are smaller/greater than the pivot
  swap(i, high)
  //return index of pivot
  return i
}
*/
